
推荐阅读: [变量生命周期](https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/)

#### 2.2.2.1 块级作用域的变量声明与一般 var 声明

除了以下三点不同，let 的语法以及使用场景都与 var 一致:

- var 声明的变量，其作用域为当前函数、模块或全局；let 声明的变量，其作用域总是在当前的代码块，例如语句块。
- 在同一个代码块中，可以用 var 来多次声明变量名，这在语法分析中与声明一次没有区别。而用 let 却只能申明一次，覆盖一个已经声明的 let 变量(或者用 let 去覆盖一个已声明的标识符)会导致语法错误。
- 用户代码可以在声明语句之前使用所声明的 var 变量，这时该变量的值是 undefined;而 let 声明的变量必须先声明后使用，声明语句之前的代码引用了 let 变量会触发异常，这也会导致 typeof 成为一个不安全的运算符。

#### 2.2.4.1 常量声明

ECMAScript 标准约定，修改常量值总是将导致异常。但是出于历史原因，在 ES5 兼容环境，或者在 ES6 模拟环境(例如，通过声明只读属性来模拟 const 声明) 中， 对非严格模式下的常量置值并不会导致异常。

#### 2.2.4.3 函数申明

在 ES5 以后的规范中，明确的规定了在表达式中出现的具名函数名只影响该函数内的代码，而不会影响该表达式所在的作用域，示例如下：

```js
// 在if语句的条件表达式中使用具名函数foo
if (function foo() {}) {
}
// 在早期的JScript中， 会显示有效的类型名 'function'
// 这是因为上述foo函数会声明在全局，这是不规范的实现。
console.log(typeof foo); // ES5 以后会打印 undefined
```
