# 摘自 JavaScript 正则迷你书(老姚)

作者：老姚
链接：https://juejin.im/post/5965943ff265da6c30653879
来源：掘金

## 字符匹配攻略

### 模糊匹配

- 有两个方向上的“模糊”：横向模糊和纵向模糊。

#### 横向模糊匹配

- 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。
- 其实现的方式是使用量词。譬如{m,n}，表示连续出现最少 m 次，最多 n 次。

```javascript
const regex = /ab{2,5}c/g;
const string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
console.log(string.match(regex));
// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

注意：案例中用的正则是/ab{2,5}c/g，后面多了 g，它是正则的一个修饰符。表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。g 是单词 global 的首字母。

#### 纵向模糊匹配

- 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。
- 其实现的方式是使用字符组。譬如[abc]，表示该字符是可以字符“a”、“b”、“c”中的任何一个。

```javascript
const regex = /a[123]b/g;
const string = "a0b a1b a2b a3b a4b";
console.log(string.match(regex));
// => ["a1b", "a2b", "a3b"]
```

### 字符组

- 需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一。

#### 范围表示法

如果字符组里的字符特别多的话，可以使用范围表示法。

比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]。用连字符-来省略和简写。

因为连字符有特殊用途，那么要匹配“a”、“-”、“z”这三者中任意一个字符，该怎么做呢？

不能写成[a-z]，因为其表示小写字符中的任何一个字符。

可以写成如下的方式：[-az]或[az-]或[a\-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。

#### 排除字符组

纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是"a"、"b"、"c"。

此时就是排除字符组（反义字符组）的概念。例如[^abc]，表示是一个除"a"、"b"、"c"之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念。

当然，也有相应的范围表示法。

#### 常见的简写形式

系统自带的简写形式。

> \d 就是[0-9]。表示是一位数字。记忆方式：其英文是 digit（数字）。
>
> \D 就是[^0-9]。表示除数字外的任意字符。
>
> \w 就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w 是 word 的简写，也称单词字符。
>
> \W 是[^0-9a-za-z_]。非单词字符。
>
> \s 是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s 是 space character 的首字母。
>
> \S 是[^ \t\v\n\r\f]。 非空白符。
>
> .就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。

如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个。

### 量词

#### 简写形式

> {m,} 表示至少出现 m 次。
>
> {m} 等价于{m,m}，表示出现 m 次。
>
> ? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
>
> \+ (和 md 语法冲突了就是单个+号) 等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
>
> \* (和 md 语法冲突了就是单个\*号) 等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。

#### 贪婪匹配和惰性匹配

默认是贪婪匹配，它会尽可能多的匹配。只要在能力范围内，越多越好。

惰性匹配，就是尽可能少的匹配。 只要满足最低要求，就不在往下尝试。

通过在量词后面加个问号就能实现惰性匹配，因此`所有惰性匹配情形`如下：

> {m,n}?
>
> {m,}?
>
> ??
>
> +?
>
> \*?

### 多选分支

- 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。

具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用|（管道符）分隔，表示其中任何之一。

但有个事实我们应该`注意`，比如我用/good|goodbye/，去匹配"goodbye"字符串时，结果是"good"：

```js
const regex = /good|goodbye/g;
const string = "goodbye";
console.log(string.match(regex));
// => ["good"]
```

而把正则改成/goodbye|good/，结果是：

```js
const regex = /goodbye|good/g;
const string = "goodbye";
console.log(string.match(regex));
// => ["goodbye"]
```

也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。

## 位置匹配攻略

### 什么是位置

- 位置是相邻字符之间的位置

如: ^h^e^l^l^o^ ^代表位置

### 如何匹配位置

在 ES5 中，共有 6 个锚字符：

> ^ \$ \b \B (?=p) (?!p)

^（脱字符） 匹配开头，在多行匹配中匹配行开头。

\$（美元符号）匹配结尾，在多行匹配中匹配行结尾。

比如我们把字符串的开头和结尾用"#"替换（`位置可以替换成字符的！`）：

```js
const result = "hello".replace(/^|$/g, "#");
console.log(result);
// => "#hello#"
```

多行匹配模式时，二者是行的概念，这个需要我们的注意：

```js
const result = "I\nlove\njavascript".replace(/^|$/gm, "#");
console.log(result);
/*
#I#
#love#
#javascript#
*/
```

\b 是单词边界，具体就是\w 和\W 之间的位置，也包括\w 和^之间的位置，也包括\w 和\$之间的位置。

```js
const result = "[JS] Lesson_01.mp4".replace(/\b/g, "#");
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```

\B 就是\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B 的。

具体说来就是\w 与\w、\W 与\W、^与\W，\W 与\$之间的位置。

```javascript
const result = "[JS] Lesson_01.mp4".replace(/\B/g, "#");
console.log(result);
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

(?=p)，其中 p 是一个子模式，即 p 前面的位置。

```js
const result = "hello".replace(/(?=l)/g, "#");
console.log(result);
// => "he#l#lo"
```

(?!p)就是(?=p)的反面意思，比如：

```js
const result = "hello".replace(/(?!l)/g, "#");
console.log(result);
// => "#h#ell#o#"
```

ES6 中，还支持 (?<=p)和(?<!p)

### 位置的特性

对于位置的理解，我们可以`理解`成空字符""。

比如"hello"字符串等价于如下的形式：

"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + "";

也等价于：

"hello" == "" + "" + "hello"

## 括号的作用

- 供了分组，便于我们引用它。

- 引用某个分组，会有两种情形：在 JavaScript 里引用它，在正则表达式里引用它。

### 分组和分支结构

#### 分组

/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/。

#### 分支结构

在多选分支结构(p1|p2)中，此处括号提供了子表达式的所有可能。

### 引用分组

- 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。

以日期为例。假设格式是 yyyy-mm-dd 的，
提取出年、月、日，可以这么做：

```js
const regex = /(\d{4})-(\d{2})-(\d{2})/;
const string = "2017-06-12";
console.log(string.match(regex));
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

`match`返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符 g，match 返回的数组格式是不一样的）。

也可以使用正则对象的exec方法：
```js
const regex = /(\d{4})-(\d{2})-(\d{2})/;
const string = "2017-06-12";
console.log(regex.exec(string));
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

### 反向引用

假设我们想要求分割符前后一致,此时需要使用反向引用：

```js
const regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/
const string1 = "2017-06-12"
const string2 = "2017/06/12"
const string3 = "2017.06.12"
const string4 = "2016-06/12"
console.log( regex.test(string1) ); // true
console.log( regex.test(string2) ); // true
console.log( regex.test(string3) ); // true
console.log( regex.test(string4) ); // false
```
注意里面的\1，表示的引用之前的那个分组(-|\/|\.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。

我们知道了\1的含义后，那么\2和\3的概念也就理解了，即分别指代第二个和第三个分组。

#### 括号嵌套怎么办

以左括号（开括号）为准。比如：
```js
const regex = /^((\d)(\d(\d)))\1\2\3\4$/
const string = "1231231233"
console.log( regex.test(string) ); // true
console.log( RegExp.$1 ); // 123
console.log( RegExp.$2 ); // 1
console.log( RegExp.$3 ); // 23
console.log( RegExp.$4 ); // 3
```
- 我们可以看看这个正则匹配模式：
- 第一个字符是数字，比如说1，
- 第二个字符是数字，比如说2，
- 第三个字符是数字，比如说3，
- 接下来的是\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是123，
- 接下来的是\2，找到第2个开括号，对应的分组，匹配的内容是1，
- 接下来的是\3，找到第3个开括号，对应的分组，匹配的内容是23，
- 最后的是\4，找到第3个开括号，对应的分组，匹配的内容是3。

#### \10表示什么呢
- 即\10是表示第10个分组，还是\1和0呢？
- 答案是前者，虽然一个正则里出现\10比较罕见。测试如下：
```js
const regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/
const string = "123456789# ######"
console.log( regex.test(string) );
// => true
```

#### 引用不存在的分组会怎样？
- 因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，`只是匹配反向引用的字符本身`。例如\2，就匹配"\2"。注意"\2"表示对"2"进行了转意。
```js
const regex = /\1\2\3\4\5\6\7\8\9/
console.log( regex.test("\1\2\3\4\5\6\7\8\9") ); 
console.log( "\1\2\3\4\5\6\7\8\9".split("") );
```

### 非捕获分组
- 之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。
如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)。


## 回溯法
- 简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。

1. 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。
2. 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。
3. 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。

        既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些DFA引擎。
        而JS的正则引擎是NFA，NFA是“非确定型有限自动机”的简写。
        大部分语言中的正则都是NFA，为啥它这么流行呢？
        答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。
        


